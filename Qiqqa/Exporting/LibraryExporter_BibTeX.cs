using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Qiqqa.DocumentLibrary;
using Qiqqa.Documents.PDF;
using Utilities;
using Utilities.BibTex;
using Utilities.Collections;
using Utilities.Misc;

namespace Qiqqa.Exporting
{
    class LibraryExporter_BibTeX
    {
        internal static void Export(Library library, List<PDFDocument> pdf_documents, string base_path, Dictionary<string, PDFDocumentExportItem> pdf_document_export_items, bool include_additional_fields)
        {
            string filename = base_path + @"Qiqqa.bib";
            ExportBibTeX(pdf_documents, filename, pdf_document_export_items, include_additional_fields);
        }

        public static void ExportBibTeX(List<PDFDocument> pdf_documents, string filename, bool include_additional_fields)
        {
            Dictionary<string, PDFDocumentExportItem> pdf_document_export_items = new Dictionary<string, PDFDocumentExportItem>();
            ExportBibTeX(pdf_documents, filename, pdf_document_export_items, include_additional_fields);
        }

        public static void ExportBibTeX(List<PDFDocument> pdf_documents, string filename, Dictionary<string, PDFDocumentExportItem> pdf_document_export_items, bool include_additional_fields)
        {
            Logging.Info("Exporting entries to BibTex");

            // Write out the header
            DateTime now = DateTime.Now;
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("% -------------------------------------------------------------------------");
            sb.AppendLine(String.Format("% This BibTex file was generated by Qiqqa ({0}?ref=EXPBIB)", Common.Configuration.WebsiteAccess.Url_Documentation4Qiqqa));
            sb.AppendLine(String.Format("% {0} {1}", now.ToLongDateString(), now.ToLongTimeString()));
            sb.AppendLine("% Version 3");
            sb.AppendLine("% -------------------------------------------------------------------------");
            sb.AppendLine();

            // Write out the entries
            for (int i = 0; i < pdf_documents.Count; ++i)
            {
                PDFDocument pdf_document = pdf_documents[i];

                try
                {
                    StatusManager.Instance.UpdateStatus("BibTexExport", String.Format("Exporting entry {0} of {1}", i, pdf_documents.Count), i, pdf_documents.Count);

                    // Get the bibtex
                    string bibtex = pdf_document.BibTex;

                    // If there is no bibtex, make a record
                    if (String.IsNullOrEmpty(bibtex))
                    {
                        bibtex = BibTexTools.GetEmplyArticleBibTeXTemplate();

                        string title = pdf_document.TitleCombined;
                        if (Constants.TITLE_UNKNOWN != title) bibtex = BibTexTools.SetAuthor(bibtex, title);

                        string author = pdf_document.AuthorsCombined;
                        if (Constants.UNKNOWN_AUTHORS != author) bibtex = BibTexTools.SetAuthor(bibtex, author);

                        string year = pdf_document.YearCombined;
                        if (Constants.UNKNOWN_YEAR != year) bibtex = BibTexTools.SetYear(bibtex, year);
                    }

                    // NB: The ADDITION of the filename and tags causes the bibtex to be reparsed and formatted, 
                    // which currently loses all the nifty bibtex formatting language (e.g. double braces, etc)
                    //
                    // Once the bibtex parser is smarter, we can add this back in.  Or perhaps make it an option...
                    if (include_additional_fields)
                    {
                        // If we have an export filename, fill it in!
                        if (pdf_document_export_items.ContainsKey(pdf_document.Fingerprint))
                        {
                            string bibtex_filename = pdf_document_export_items[pdf_document.Fingerprint].filename;
                            string bibtex_file = ConvertNormalFilenameToZoteroFilename(filename, bibtex_filename);

                            bibtex = BibTexTools.SetField(bibtex, "filename", bibtex_filename);
                            bibtex = BibTexTools.SetField(bibtex, "file", bibtex_file);
                        }
                        else
                        {
                            if (pdf_document.DocumentExists)
                            {
                                string bibtex_filename = pdf_document.DocumentPath;
                                string bibtex_file = ConvertNormalFilenameToZoteroFilename(filename, bibtex_filename);

                                bibtex = BibTexTools.SetField(bibtex, "filename", bibtex_filename);
                                bibtex = BibTexTools.SetField(bibtex, "file", bibtex_file);
                            }
                        }

                        // Fill in the tags and autotags
                        {
                            string tags = pdf_document.Tags;
                            if (!String.IsNullOrEmpty(tags))
                            {
                                bibtex = BibTexTools.SetField(bibtex, "Tags", tags);
                            }

                            HashSet<string> autotags_set = pdf_document.Library.AITagManager.AITags.GetTagsWithDocument(pdf_document.Fingerprint);
                            string autotags = ArrayFormatter.ListElements(autotags_set.ToList(), ";");
                            if (!String.IsNullOrEmpty(autotags))
                            {
                                bibtex = BibTexTools.SetField(bibtex, "AutoTags", autotags);
                            }

                            string keywords = BibTexTools.GetField(bibtex, "keywords");
                            if (!String.IsNullOrEmpty(tags))
                            {
                                if (!String.IsNullOrEmpty(keywords)) keywords = keywords + ";";
                                keywords = keywords + tags;
                            }
                            if (!String.IsNullOrEmpty(autotags))
                            {
                                if (!String.IsNullOrEmpty(keywords)) keywords = keywords + ";";
                                keywords = keywords + autotags;
                            }
                            if (!String.IsNullOrEmpty(keywords))
                            {
                                bibtex = BibTexTools.SetField(bibtex, "keywords", keywords);
                            }
                        }
                    }
                     

                    // Append the bibtex
                    if (!String.IsNullOrEmpty(bibtex))
                    {
                        sb.AppendLine(bibtex);
                        sb.AppendLine();
                    }
                }

                catch (Exception ex)
                {
                    Logging.Error(ex, "There was a problem exporting the bibtex for " + pdf_document);
                }
            }

            // Write to disk
            File.WriteAllText(filename, sb.ToString());

            StatusManager.Instance.UpdateStatus("BibTexExport", String.Format("Exported your BibTex entries to {0}", filename));
        }

        private static string ConvertNormalFilenameToZoteroFilename(string bibtex_base_filename, string filename)
        {
            string bibtex_base_path = Path.GetDirectoryName(bibtex_base_filename);
            
            string file = Path.GetFileName(filename);
            string path = filename;
            
            /// Try shrink it to a relative path
            if (path.StartsWith(bibtex_base_path))
            {
                path = path.Substring(bibtex_base_path.Length + 1);
            }
            else
            {
                Logging.Warn("Unable to convert path to Zotero form: {0}", path);
            }

            // Replace the slashes
            path = path.Replace('\\', '/');

            // Concatenate
            string export_string =
                ""
                + file
                + ":"
                + path
                + ":"
                + "application/pdf";

            return export_string;
        }
    }
}
